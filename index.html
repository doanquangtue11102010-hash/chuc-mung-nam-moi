<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chúc Mừng Năm Mới — Pháo Hoa</title>
  <style>
    html,body{height:100%;margin:0;background:#03020a;overflow:hidden;font-family:system-ui,Segoe UI, Roboto, "Helvetica Neue", Arial}
    #canvas{position:fixed;inset:0;display:block}
    .overlay{position:fixed;left:50%;top:18%;transform:translateX(-50%);text-align:center;color:#fff;pointer-events:none}
    .title{font-size:clamp(28px,6vw,56px);font-weight:800;letter-spacing:1px;text-shadow:0 6px 30px rgba(0,0,0,0.6),0 0 30px rgba(255,200,80,0.12)}
    .subtitle{margin-top:8px;font-size:clamp(14px,2.2vw,20px);opacity:0.95;color:#ffd;} 
    .hint{position:fixed;left:50%;bottom:24px;transform:translateX(-50%);color:#ddd;opacity:.7;font-size:13px}
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="overlay">
    <div class="title">Chúc Mừng Năm Mới 2026</div>
    <div class="subtitle">Chúc bạn an khang thịnh vượng — Năm mới nhiều may mắn!</div>
  </div>
  <div class="controls" style="position:fixed;left:50%;top:50%;transform:translateX(-50%);display:flex;gap:.6rem;flex-wrap:wrap;justify-content:center">
  </div>
  <div class="hint">Nhấp hoặc chạm để bắn pháo hoa • Tự động bắn mỗi vài giây</div>

  <script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  let w=canvas.width=innerWidth, h=canvas.height=innerHeight;
  const rand = (a,b)=> Math.random()*(b-a)+a;

  window.addEventListener('resize', ()=>{w=canvas.width=innerWidth;h=canvas.height=innerHeight});

  const colors = ['#ff3b3b','#ffb86b','#ffe66d','#8be9fd','#50fa7b','#bd93f9','#ff6bcb'];

  class Particle{
    constructor(x,y,dx,dy,color,size,life){
      this.x=x;this.y=y;this.vx=dx;this.vy=dy;this.color=color;this.size=size;this.life=life;this.age=0;this.alpha=1
    }
    update(dt){
      this.vy += 0.06 * dt; // gravity
      this.vx *= 0.998; this.vy *= 0.998; // air
      this.x += this.vx * dt; this.y += this.vy * dt;
      this.age += dt; this.alpha = Math.max(0,1 - this.age/this.life);
    }
    draw(ctx){
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.globalAlpha = this.alpha;
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x,this.y,this.size,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  let particles = [];

  function explode(x,y,palette,count=40,spread=6,speed=6,life=110){
    if(particles.length > 200) return; // limit particles for performance
    for(let i=0;i<count;i++){
      const a = Math.random()*Math.PI*2;
      const s = Math.pow(Math.random(),0.6)*speed*rand(0.7,1.3);
      const vx = Math.cos(a)*s;
      const vy = Math.sin(a)*s;
      const c = palette[Math.floor(Math.random()*palette.length)];
      const size = Math.max(1, Math.random()*3.5);
      const p = new Particle(x,y,vx,vy,c,size,life*rand(0.7,1.3));
      particles.push(p);
    }
    playPop();
  }

  // rockets that travel up then explode
  class Rocket{
    constructor(x,y,tx,color){this.x=x;this.y=y;this.tx=tx;this.vx=(tx-x)/30;this.vy=-rand(6,9);this.color=color;this.alive=true}
    update(dt){
      this.x += this.vx*dt; this.y += this.vy*dt; this.vy += 0.09*dt;
      if(this.vy>0 || this.y < h*0.25 || Math.random()<0.002) { this.alive=false; explode(this.x,this.y,colors,40,8,9,140) }
    }
    draw(ctx){ctx.save();ctx.globalCompositeOperation='lighter';ctx.fillStyle=this.color;ctx.beginPath();ctx.arc(this.x,this.y,2.8,0,Math.PI*2);ctx.fill();ctx.restore();}
  }

  let rockets = [];

  function launch(x=null){
    const sx = x ?? rand(w*0.15,w*0.85);
    const color = colors[Math.floor(Math.random()*colors.length)];
    rockets.push(new Rocket(sx,h,rand(0,w),color));
  }

  // nice fading background to create trails
  let lastTime = 0;
  function frame(currentTime = performance.now()){
    if (currentTime - lastTime < 1000/30) {
      requestAnimationFrame(frame);
      return;
    }
    lastTime = currentTime;
    // fade with a translucent rectangle to create trailing effect
    ctx.globalCompositeOperation='source-over';
    ctx.fillStyle = 'rgba(3,2,10,0.22)';
    ctx.fillRect(0,0,w,h);

    // draw rockets
    for(let i=rockets.length-1;i>=0;i--){
      rockets[i].update(1);
      rockets[i].draw(ctx);
      if(!rockets[i].alive) rockets.splice(i,1);
    }

    // update particles
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.update(1);
      if(p.alpha<=0.01 || p.age>p.life) particles.splice(i,1);
      else p.draw(ctx);
    }
    requestAnimationFrame(frame);
  }

  // automatic launches
  setInterval(()=>{ if(Math.random()<0.7) launch(); }, 2000);

  // user interaction
  let lastTap=0;
  function pointerHandler(e){
    const now = Date.now();
    lastTap = now;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX ?? e.touches?.[0]?.clientX) - rect.left;
    for(let i=0;i<1;i++) launch(x);
    if (!musicNodes && autoStart) {
      musicNodes = startBackgroundMusic();
      autoStart = false;
    }
  }
  window.addEventListener('mousedown', pointerHandler);
  window.addEventListener('touchstart', pointerHandler);

  // small WebAudio click/pop for explosions
  let audioCtx=null;
  function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }
  function playPop(){ try{ ensureAudio(); const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type='sine'; o.frequency.value = rand(300,900); g.gain.value=0.02; o.connect(g); g.connect(audioCtx.destination); o.start(); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+0.25); o.stop(audioCtx.currentTime+0.25);}catch(e){}
  }

  // background music
  let musicNodes = null;
  let autoStart = true;
  function startBackgroundMusic() {
    if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    const lfo = audioCtx.createOscillator();
    const lfoGain = audioCtx.createGain();
    o.type = 'triangle';
    o.frequency.value = 110;
    g.gain.value = 0.005;
    lfo.type = 'sine';
    lfo.frequency.value = 0.1;
    lfoGain.gain.value = 10;
    lfo.connect(lfoGain);
    lfoGain.connect(o.frequency);
    o.connect(g);
    g.connect(audioCtx.destination);
    o.start();
    lfo.start();
    return {o, lfo};
  }

  // initial burst
  for(let i=0;i<3;i++) setTimeout(()=>launch(), i*400);
  frame();

  // auto start music
  try {
    musicNodes = startBackgroundMusic();
  } catch(e) {
    console.log('Autoplay blocked, music will start on first click');
  }
  </script>
</body>
</html>
